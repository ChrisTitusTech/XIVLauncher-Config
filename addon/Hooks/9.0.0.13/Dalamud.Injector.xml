<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Dalamud.Injector</name>
    </assembly>
    <members>
        <member name="T:Dalamud.Injector.EntryPoint">
            <summary>
            Entrypoint to the program.
            </summary>
        </member>
        <member name="T:Dalamud.Injector.EntryPoint.MainDelegate">
            <summary>
            A delegate used during initialization of the CLR from Dalamud.Injector.Boot.
            </summary>
            <param name="argc">Count of arguments.</param>
            <param name="argvPtr">char** string arguments.</param>
        </member>
        <member name="M:Dalamud.Injector.EntryPoint.Main(System.Int32,System.IntPtr)">
            <summary>
            Start the Dalamud injector.
            </summary>
            <param name="argc">Count of arguments.</param>
            <param name="argvPtr">byte** string arguments.</param>
        </member>
        <member name="M:Dalamud.Injector.EntryPoint.EncodeParameterArgument(System.String,System.Boolean)">
             <summary>
                 This routine appends the given argument to a command line such that
                 CommandLineToArgvW will return the argument string unchanged. Arguments
                 in a command line should be separated by spaces; this function does
                 not add these spaces.
            
                 Taken from https://stackoverflow.com/questions/5510343/escape-command-line-arguments-in-c-sharp
                 and https://blogs.msdn.microsoft.com/twistylittlepassagesallalike/2011/04/23/everyone-quotes-command-line-arguments-the-wrong-way/.
             </summary>
             <param name="argument">Supplies the argument to encode.</param>
             <param name="force">
                 Supplies an indication of whether we should quote the argument even if it
                 does not contain any characters that would ordinarily require quoting.
             </param>
        </member>
        <member name="T:Dalamud.Injector.ExistingProcess">
            <summary>
            Class representing an already held process handle.
            </summary>
        </member>
        <member name="M:Dalamud.Injector.ExistingProcess.#ctor(System.IntPtr)">
            <summary>
            Initializes a new instance of the <see cref="T:Dalamud.Injector.ExistingProcess"/> class.
            </summary>
            <param name="handle">The existing held process handle.</param>
        </member>
        <member name="T:Dalamud.Injector.GameStart">
            <summary>
            Class responsible for starting the game and stripping ACL protections from processes.
            </summary>
        </member>
        <member name="M:Dalamud.Injector.GameStart.LaunchGame(System.String,System.String,System.String,System.Boolean,System.Action{System.Diagnostics.Process},System.Boolean)">
            <summary>
            Start a process without ACL protections.
            </summary>
            <param name="workingDir">The working directory.</param>
            <param name="exePath">The path to the executable file.</param>
            <param name="arguments">Arguments to pass to the executable file.</param>
            <param name="dontFixAcl">Don't actually fix the ACL.</param>
            <param name="beforeResume">Action to execute before the process is started.</param>
            <param name="waitForGameWindow">Wait for the game window to be ready before proceeding.</param>
            <returns>The started process.</returns>
            <exception cref="T:System.ComponentModel.Win32Exception">Thrown when a win32 error occurs.</exception>
            <exception cref="T:Dalamud.Injector.GameStart.GameStartException">Thrown when the process did not start correctly.</exception>
        </member>
        <member name="M:Dalamud.Injector.GameStart.CopyAclFromSelfToTargetProcess(System.IntPtr)">
            <summary>
            Copies ACL of current process to the target process.
            </summary>
            <param name="hProcess">Native handle to the target process.</param>
            <exception cref="T:System.ComponentModel.Win32Exception">Thrown when a win32 error occurs.</exception>
        </member>
        <member name="M:Dalamud.Injector.GameStart.ClaimSeDebug">
            <summary>
            Claim a SE Debug Privilege.
            </summary>
        </member>
        <member name="T:Dalamud.Injector.GameStart.GameStartException">
            <summary>
            Exception thrown when the process has exited before a window could be found.
            </summary>
        </member>
        <member name="M:Dalamud.Injector.GameStart.GameStartException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Dalamud.Injector.GameStart.GameStartException"/> class.
            </summary>
            <param name="message">The message to pass on.</param>
        </member>
        <member name="T:Dalamud.Injector.Injector">
            <summary>
            This class implements injecting into a remote process. It is a highly stripped down version of the
            https://github.com/Reloaded-Project injector/assembler implementation due to issues with Lutris and
            Wine.
            </summary>
        </member>
        <member name="M:Dalamud.Injector.Injector.#ctor(System.Diagnostics.Process,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Dalamud.Injector.Injector"/> class.
            </summary>
            <param name="targetProcess">Process to inject.</param>
            <param name="disposeTargetProcess">Dispose given process on disposing self.</param>
        </member>
        <member name="M:Dalamud.Injector.Injector.Finalize">
            <summary>
            Finalizes an instance of the <see cref="T:Dalamud.Injector.Injector"/> class.
            </summary>
        </member>
        <member name="M:Dalamud.Injector.Injector.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Dalamud.Injector.Injector.LoadLibrary(System.String,System.IntPtr@)">
            <summary>
            Load a module by absolute file path.
            </summary>
            <param name="modulePath">Absolute file path.</param>
            <param name="address">Address to the module.</param>
        </member>
        <member name="M:Dalamud.Injector.Injector.GetFunctionAddress(System.IntPtr,System.String,System.UIntPtr@)">
            <summary>
            Get the address of an exported module function.
            </summary>
            <param name="module">Module address.</param>
            <param name="functionName">Name of the exported method.</param>
            <param name="address">Address to the function.</param>
        </member>
        <member name="M:Dalamud.Injector.Injector.CallRemoteFunction(System.UIntPtr,System.UIntPtr,System.UInt32@)">
            <summary>
            Call a method in a remote process via CreateRemoteThread.
            </summary>
            <param name="methodAddress">Method address.</param>
            <param name="parameterAddress">Parameter address.</param>
            <param name="exitCode">Thread exit code.</param>
        </member>
        <member name="M:Dalamud.Injector.LegacyBlowfish.#ctor(System.Byte[])">
            <summary>
            Initializes a new instance of the <see cref="T:Dalamud.Injector.LegacyBlowfish"/> class.
            </summary>
            <param name="key">The key to use.</param>
        </member>
        <member name="T:Dalamud.Injector.NativeFunctions">
            <summary>
            Native user32 functions.
            </summary>
            <summary>
            Native kernel32 functions.
            </summary>
        </member>
        <member name="T:Dalamud.Injector.NativeFunctions.MessageBoxType">
            <summary>
            MB_* from winuser.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.MessageBoxType.DefaultValue">
            <summary>
            The default value for any of the various subtypes.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.MessageBoxType.AbortRetryIgnore">
            <summary>
            The message box contains three push buttons: Abort, Retry, and Ignore.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.MessageBoxType.CancelTryContinue">
            <summary>
            The message box contains three push buttons: Cancel, Try Again, Continue. Use this message box type instead
            of MB_ABORTRETRYIGNORE.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.MessageBoxType.Help">
            <summary>
            Adds a Help button to the message box. When the user clicks the Help button or presses F1, the system sends
            a WM_HELP message to the owner.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.MessageBoxType.Ok">
            <summary>
            The message box contains one push button: OK. This is the default.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.MessageBoxType.OkCancel">
            <summary>
            The message box contains two push buttons: OK and Cancel.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.MessageBoxType.RetryCancel">
            <summary>
            The message box contains two push buttons: Retry and Cancel.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.MessageBoxType.YesNo">
            <summary>
            The message box contains two push buttons: Yes and No.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.MessageBoxType.YesNoCancel">
            <summary>
            The message box contains three push buttons: Yes, No, and Cancel.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.MessageBoxType.IconExclamation">
            <summary>
            An exclamation-point icon appears in the message box.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.MessageBoxType.IconWarning">
            <summary>
            An exclamation-point icon appears in the message box.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.MessageBoxType.IconInformation">
            <summary>
            An icon consisting of a lowercase letter i in a circle appears in the message box.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.MessageBoxType.IconAsterisk">
            <summary>
            An icon consisting of a lowercase letter i in a circle appears in the message box.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.MessageBoxType.IconQuestion">
            <summary>
            A question-mark icon appears in the message box.
            The question-mark message icon is no longer recommended because it does not clearly represent a specific type
            of message and because the phrasing of a message as a question could apply to any message type. In addition,
            users can confuse the message symbol question mark with Help information. Therefore, do not use this question
            mark message symbol in your message boxes. The system continues to support its inclusion only for backward
            compatibility.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.MessageBoxType.IconStop">
            <summary>
            A stop-sign icon appears in the message box.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.MessageBoxType.IconError">
            <summary>
            A stop-sign icon appears in the message box.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.MessageBoxType.IconHand">
            <summary>
            A stop-sign icon appears in the message box.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.MessageBoxType.DefButton1">
            <summary>
            The first button is the default button.
            MB_DEFBUTTON1 is the default unless MB_DEFBUTTON2, MB_DEFBUTTON3, or MB_DEFBUTTON4 is specified.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.MessageBoxType.DefButton2">
            <summary>
            The second button is the default button.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.MessageBoxType.DefButton3">
            <summary>
            The third button is the default button.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.MessageBoxType.DefButton4">
            <summary>
            The fourth button is the default button.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.MessageBoxType.ApplModal">
            <summary>
            The user must respond to the message box before continuing work in the window identified by the hWnd parameter.
            However, the user can move to the windows of other threads and work in those windows. Depending on the hierarchy
            of windows in the application, the user may be able to move to other windows within the thread. All child windows
            of the parent of the message box are automatically disabled, but pop-up windows are not. MB_APPLMODAL is the
            default if neither MB_SYSTEMMODAL nor MB_TASKMODAL is specified.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.MessageBoxType.SystemModal">
            <summary>
            Same as MB_APPLMODAL except that the message box has the WS_EX_TOPMOST style.
            Use system-modal message boxes to notify the user of serious, potentially damaging errors that require immediate
            attention (for example, running out of memory). This flag has no effect on the user's ability to interact with
            windows other than those associated with hWnd.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.MessageBoxType.TaskModal">
            <summary>
            Same as MB_APPLMODAL except that all the top-level windows belonging to the current thread are disabled if the
            hWnd parameter is NULL. Use this flag when the calling application or library does not have a window handle
            available but still needs to prevent input to other windows in the calling thread without suspending other threads.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.MessageBoxType.DefaultDesktopOnly">
            <summary>
            Same as desktop of the interactive window station. For more information, see Window Stations. If the current
            input desktop is not the default desktop, MessageBox does not return until the user switches to the default
            desktop.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.MessageBoxType.Right">
            <summary>
            The text is right-justified.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.MessageBoxType.RtlReading">
            <summary>
            Displays message and caption text using right-to-left reading order on Hebrew and Arabic systems.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.MessageBoxType.SetForeground">
            <summary>
            The message box becomes the foreground window. Internally, the system calls the SetForegroundWindow function
            for the message box.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.MessageBoxType.Topmost">
            <summary>
            The message box is created with the WS_EX_TOPMOST window style.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.MessageBoxType.ServiceNotification">
            <summary>
            The caller is a service notifying the user of an event. The function displays a message box on the current active
            desktop, even if there is no user logged on to the computer.
            </summary>
        </member>
        <member name="M:Dalamud.Injector.NativeFunctions.MessageBoxW(System.IntPtr,System.String,System.String,Dalamud.Injector.NativeFunctions.MessageBoxType)">
            <summary>
            Displays a modal dialog box that contains a system icon, a set of buttons, and a brief application-specific message,
            such as status or error information. The message box returns an integer value that indicates which button the user
            clicked.
            </summary>
            <param name="hWnd">
            A handle to the owner window of the message box to be created. If this parameter is NULL, the message box has no
            owner window.
            </param>
            <param name="text">
            The message to be displayed. If the string consists of more than one line, you can separate the lines using a carriage
            return and/or linefeed character between each line.
            </param>
            <param name="caption">
            The dialog box title. If this parameter is NULL, the default title is Error.</param>
            <param name="type">
            The contents and behavior of the dialog box. This parameter can be a combination of flags from the following groups
            of flags.
            </param>
            <returns>
            If a message box has a Cancel button, the function returns the IDCANCEL value if either the ESC key is pressed or
            the Cancel button is selected. If the message box has no Cancel button, pressing ESC will no effect - unless an
            MB_OK button is present. If an MB_OK button is displayed and the user presses ESC, the return value will be IDOK.
            If the function fails, the return value is zero.To get extended error information, call GetLastError. If the function
            succeeds, the return value is one of the ID* enum values.
            </returns>
        </member>
        <member name="T:Dalamud.Injector.NativeFunctions.AllocationType">
            <summary>
            MEM_* from memoryapi.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.AllocationType.CoalescePlaceholders">
            <summary>
            To coalesce two adjacent placeholders, specify MEM_RELEASE | MEM_COALESCE_PLACEHOLDERS. When you coalesce
            placeholders, lpAddress and dwSize must exactly match those of the placeholder.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.AllocationType.PreservePlaceholder">
            <summary>
            Frees an allocation back to a placeholder (after you've replaced a placeholder with a private allocation using
            VirtualAlloc2 or Virtual2AllocFromApp). To split a placeholder into two placeholders, specify
            MEM_RELEASE | MEM_PRESERVE_PLACEHOLDER.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.AllocationType.Commit">
            <summary>
            Allocates memory charges (from the overall size of memory and the paging files on disk) for the specified reserved
            memory pages. The function also guarantees that when the caller later initially accesses the memory, the contents
            will be zero. Actual physical pages are not allocated unless/until the virtual addresses are actually accessed.
            To reserve and commit pages in one step, call VirtualAllocEx with MEM_COMMIT | MEM_RESERVE. Attempting to commit
            a specific address range by specifying MEM_COMMIT without MEM_RESERVE and a non-NULL lpAddress fails unless the
            entire range has already been reserved. The resulting error code is ERROR_INVALID_ADDRESS. An attempt to commit
            a page that is already committed does not cause the function to fail. This means that you can commit pages without
            first determining the current commitment state of each page. If lpAddress specifies an address within an enclave,
            flAllocationType must be MEM_COMMIT.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.AllocationType.Reserve">
            <summary>
            Reserves a range of the process's virtual address space without allocating any actual physical storage in memory
            or in the paging file on disk. You commit reserved pages by calling VirtualAllocEx again with MEM_COMMIT. To
            reserve and commit pages in one step, call VirtualAllocEx with MEM_COMMIT | MEM_RESERVE. Other memory allocation
            functions, such as malloc and LocalAlloc, cannot use reserved memory until it has been released.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.AllocationType.Decommit">
            <summary>
            Decommits the specified region of committed pages. After the operation, the pages are in the reserved state.
            The function does not fail if you attempt to decommit an uncommitted page. This means that you can decommit
            a range of pages without first determining the current commitment state. The MEM_DECOMMIT value is not supported
            when the lpAddress parameter provides the base address for an enclave.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.AllocationType.Release">
            <summary>
            Releases the specified region of pages, or placeholder (for a placeholder, the address space is released and
            available for other allocations). After this operation, the pages are in the free state. If you specify this
            value, dwSize must be 0 (zero), and lpAddress must point to the base address returned by the VirtualAlloc function
            when the region is reserved. The function fails if either of these conditions is not met. If any pages in the
            region are committed currently, the function first decommits, and then releases them. The function does not
            fail if you attempt to release pages that are in different states, some reserved and some committed. This means
            that you can release a range of pages without first determining the current commitment state.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.AllocationType.Reset">
            <summary>
            Indicates that data in the memory range specified by lpAddress and dwSize is no longer of interest. The pages
            should not be read from or written to the paging file. However, the memory block will be used again later, so
            it should not be decommitted. This value cannot be used with any other value. Using this value does not guarantee
            that the range operated on with MEM_RESET will contain zeros. If you want the range to contain zeros, decommit
            the memory and then recommit it. When you use MEM_RESET, the VirtualAllocEx function ignores the value of fProtect.
            However, you must still set fProtect to a valid protection value, such as PAGE_NOACCESS. VirtualAllocEx returns
            an error if you use MEM_RESET and the range of memory is mapped to a file. A shared view is only acceptable
            if it is mapped to a paging file.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.AllocationType.ResetUndo">
            <summary>
            MEM_RESET_UNDO should only be called on an address range to which MEM_RESET was successfully applied earlier.
            It indicates that the data in the specified memory range specified by lpAddress and dwSize is of interest to
            the caller and attempts to reverse the effects of MEM_RESET. If the function succeeds, that means all data in
            the specified address range is intact. If the function fails, at least some of the data in the address range
            has been replaced with zeroes. This value cannot be used with any other value. If MEM_RESET_UNDO is called on
            an address range which was not MEM_RESET earlier, the behavior is undefined. When you specify MEM_RESET, the
            VirtualAllocEx function ignores the value of flProtect. However, you must still set flProtect to a valid
            protection value, such as PAGE_NOACCESS.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.AllocationType.Physical">
            <summary>
            Reserves an address range that can be used to map Address Windowing Extensions (AWE) pages. This value must
            be used with MEM_RESERVE and no other values.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.AllocationType.TopDown">
            <summary>
            Allocates memory at the highest possible address. This can be slower than regular allocations, especially when
            there are many allocations.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.AllocationType.WriteWatch">
            <summary>
            Causes the system to track pages that are written to in the allocated region. If you specify this value, you
            must also specify MEM_RESERVE. To retrieve the addresses of the pages that have been written to since the region
            was allocated or the write-tracking state was reset, call the GetWriteWatch function. To reset the write-tracking
            state, call GetWriteWatch or ResetWriteWatch. The write-tracking feature remains enabled for the memory region
            until the region is freed.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.AllocationType.LargePages">
            <summary>
            Allocates memory using large page support. The size and alignment must be a multiple of the large-page minimum.
            To obtain this value, use the GetLargePageMinimum function. If you specify this value, you must also specify
            MEM_RESERVE and MEM_COMMIT.
            </summary>
        </member>
        <member name="T:Dalamud.Injector.NativeFunctions.CreateThreadFlags">
            <summary>
            Unprefixed flags from CreateRemoteThread.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.CreateThreadFlags.RunImmediately">
            <summary>
            The thread runs immediately after creation.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.CreateThreadFlags.CreateSuspended">
            <summary>
            The thread is created in a suspended state, and does not run until the ResumeThread function is called.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.CreateThreadFlags.StackSizeParamIsReservation">
            <summary>
            The dwStackSize parameter specifies the initial reserve size of the stack. If this flag is not specified, dwStackSize specifies the commit size.
            </summary>
        </member>
        <member name="T:Dalamud.Injector.NativeFunctions.DuplicateOptions">
            <summary>
            DUPLICATE_* values for DuplicateHandle's dwDesiredAccess.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.DuplicateOptions.CloseSource">
            <summary>
            Closes the source handle. This occurs regardless of any error status returned.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.DuplicateOptions.SameAccess">
            <summary>
            Ignores the dwDesiredAccess parameter. The duplicate handle has the same access as the source handle.
            </summary>
        </member>
        <member name="T:Dalamud.Injector.NativeFunctions.MemoryProtection">
            <summary>
            PAGE_* from memoryapi.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.MemoryProtection.Execute">
            <summary>
            Enables execute access to the committed region of pages. An attempt to write to the committed region results
            in an access violation. This flag is not supported by the CreateFileMapping function.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.MemoryProtection.ExecuteRead">
            <summary>
            Enables execute or read-only access to the committed region of pages. An attempt to write to the committed region
            results in an access violation.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.MemoryProtection.ExecuteReadWrite">
            <summary>
            Enables execute, read-only, or read/write access to the committed region of pages.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.MemoryProtection.ExecuteWriteCopy">
            <summary>
            Enables execute, read-only, or copy-on-write access to a mapped view of a file mapping object. An attempt to
            write to a committed copy-on-write page results in a private copy of the page being made for the process. The
            private page is marked as PAGE_EXECUTE_READWRITE, and the change is written to the new page. This flag is not
            supported by the VirtualAlloc or VirtualAllocEx functions.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.MemoryProtection.NoAccess">
            <summary>
            Disables all access to the committed region of pages. An attempt to read from, write to, or execute the committed
            region results in an access violation. This flag is not supported by the CreateFileMapping function.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.MemoryProtection.ReadOnly">
            <summary>
            Enables read-only access to the committed region of pages. An attempt to write to the committed region results
            in an access violation. If Data Execution Prevention is enabled, an attempt to execute code in the committed
            region results in an access violation.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.MemoryProtection.ReadWrite">
            <summary>
            Enables read-only or read/write access to the committed region of pages. If Data Execution Prevention is enabled,
            attempting to execute code in the committed region results in an access violation.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.MemoryProtection.WriteCopy">
            <summary>
            Enables read-only or copy-on-write access to a mapped view of a file mapping object. An attempt to write to
            a committed copy-on-write page results in a private copy of the page being made for the process. The private
            page is marked as PAGE_READWRITE, and the change is written to the new page. If Data Execution Prevention is
            enabled, attempting to execute code in the committed region results in an access violation. This flag is not
            supported by the VirtualAlloc or VirtualAllocEx functions.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.MemoryProtection.TargetsInvalid">
            <summary>
            Sets all locations in the pages as invalid targets for CFG. Used along with any execute page protection like
            PAGE_EXECUTE, PAGE_EXECUTE_READ, PAGE_EXECUTE_READWRITE and PAGE_EXECUTE_WRITECOPY. Any indirect call to locations
            in those pages will fail CFG checks and the process will be terminated. The default behavior for executable
            pages allocated is to be marked valid call targets for CFG. This flag is not supported by the VirtualProtect
            or CreateFileMapping functions.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.MemoryProtection.TargetsNoUpdate">
            <summary>
            Pages in the region will not have their CFG information updated while the protection changes for VirtualProtect.
            For example, if the pages in the region was allocated using PAGE_TARGETS_INVALID, then the invalid information
            will be maintained while the page protection changes. This flag is only valid when the protection changes to
            an executable type like PAGE_EXECUTE, PAGE_EXECUTE_READ, PAGE_EXECUTE_READWRITE and PAGE_EXECUTE_WRITECOPY.
            The default behavior for VirtualProtect protection change to executable is to mark all locations as valid call
            targets for CFG.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.MemoryProtection.Guard">
            <summary>
            Pages in the region become guard pages. Any attempt to access a guard page causes the system to raise a
            STATUS_GUARD_PAGE_VIOLATION exception and turn off the guard page status. Guard pages thus act as a one-time
            access alarm. For more information, see Creating Guard Pages. When an access attempt leads the system to turn
            off guard page status, the underlying page protection takes over. If a guard page exception occurs during a
            system service, the service typically returns a failure status indicator. This value cannot be used with
            PAGE_NOACCESS. This flag is not supported by the CreateFileMapping function.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.MemoryProtection.NoCache">
            <summary>
            Sets all pages to be non-cachable. Applications should not use this attribute except when explicitly required
            for a device. Using the interlocked functions with memory that is mapped with SEC_NOCACHE can result in an
            EXCEPTION_ILLEGAL_INSTRUCTION exception. The PAGE_NOCACHE flag cannot be used with the PAGE_GUARD, PAGE_NOACCESS,
            or PAGE_WRITECOMBINE flags. The PAGE_NOCACHE flag can be used only when allocating private memory with the
            VirtualAlloc, VirtualAllocEx, or VirtualAllocExNuma functions. To enable non-cached memory access for shared
            memory, specify the SEC_NOCACHE flag when calling the CreateFileMapping function.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.MemoryProtection.WriteCombine">
            <summary>
            Sets all pages to be write-combined. Applications should not use this attribute except when explicitly required
            for a device. Using the interlocked functions with memory that is mapped as write-combined can result in an
            EXCEPTION_ILLEGAL_INSTRUCTION exception. The PAGE_WRITECOMBINE flag cannot be specified with the PAGE_NOACCESS,
            PAGE_GUARD, and PAGE_NOCACHE flags. The PAGE_WRITECOMBINE flag can be used only when allocating private memory
            with the VirtualAlloc, VirtualAllocEx, or VirtualAllocExNuma functions. To enable write-combined memory access
            for shared memory, specify the SEC_WRITECOMBINE flag when calling the CreateFileMapping function.
            </summary>
        </member>
        <member name="T:Dalamud.Injector.NativeFunctions.ProcessAccessFlags">
            <summary>
            PROCESS_* from processthreadsapi.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.ProcessAccessFlags.AllAccess">
            <summary>
            All possible access rights for a process object.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.ProcessAccessFlags.CreateProcess">
            <summary>
            Required to create a process.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.ProcessAccessFlags.CreateThread">
            <summary>
            Required to create a thread.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.ProcessAccessFlags.DupHandle">
            <summary>
            Required to duplicate a handle using DuplicateHandle.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.ProcessAccessFlags.QueryInformation">
            <summary>
            Required to retrieve certain information about a process, such as its token, exit code,
            and priority class (see OpenProcessToken).
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.ProcessAccessFlags.QueryLimitedInformation">
            <summary>
            Required to retrieve certain information about a process(see GetExitCodeProcess, GetPriorityClass, IsProcessInJob,
            QueryFullProcessImageName). A handle that has the PROCESS_QUERY_INFORMATION access right is automatically granted
            PROCESS_QUERY_LIMITED_INFORMATION.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.ProcessAccessFlags.SetInformation">
            <summary>
            Required to set certain information about a process, such as its priority class (see SetPriorityClass).
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.ProcessAccessFlags.SetQuote">
            <summary>
            Required to set memory limits using SetProcessWorkingSetSize.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.ProcessAccessFlags.SuspendResume">
            <summary>
            Required to suspend or resume a process.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.ProcessAccessFlags.Terminate">
            <summary>
            Required to terminate a process using TerminateProcess.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.ProcessAccessFlags.VmOperation">
            <summary>
            Required to perform an operation on the address space of a process(see VirtualProtectEx and WriteProcessMemory).
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.ProcessAccessFlags.VmRead">
            <summary>
            Required to read memory in a process using ReadProcessMemory.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.ProcessAccessFlags.VmWrite">
            <summary>
            Required to write to memory in a process using WriteProcessMemory.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.ProcessAccessFlags.Synchronize">
            <summary>
            Required to wait for the process to terminate using the wait functions.
            </summary>
        </member>
        <member name="T:Dalamud.Injector.NativeFunctions.WaitResult">
            <summary>
            WAIT_* from synchapi.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.WaitResult.Abandoned">
            <summary>
            The specified object is a mutex object that was not released by the thread that owned the mutex object
            before the owning thread terminated.Ownership of the mutex object is granted to the calling thread and
            the mutex state is set to nonsignaled. If the mutex was protecting persistent state information, you
            should check it for consistency.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.WaitResult.Object0">
            <summary>
            The state of the specified object is signaled.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.WaitResult.Timeout">
            <summary>
            The time-out interval elapsed, and the object's state is nonsignaled.
            </summary>
        </member>
        <member name="F:Dalamud.Injector.NativeFunctions.WaitResult.WAIT_FAILED">
            <summary>
            The function has failed. To get extended error information, call GetLastError.
            </summary>
        </member>
        <member name="M:Dalamud.Injector.NativeFunctions.CloseHandle(System.IntPtr)">
            <summary>
            Closes an open object handle.
            </summary>
            <param name="hObject">
            A valid handle to an open object.
            </param>
            <returns>
            If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error
            information, call GetLastError. If the application is running under a debugger, the function will throw an exception if it receives
            either a handle value that is not valid or a pseudo-handle value. This can happen if you close a handle twice, or if you call
            CloseHandle on a handle returned by the FindFirstFile function instead of calling the FindClose function.
            </returns>
        </member>
        <member name="M:Dalamud.Injector.NativeFunctions.CreateRemoteThread(System.IntPtr,System.IntPtr,System.UIntPtr,System.UIntPtr,System.UIntPtr,Dalamud.Injector.NativeFunctions.CreateThreadFlags,System.UInt32@)">
            <summary>
            Creates a thread that runs in the virtual address space of another process. Use the CreateRemoteThreadEx function
            to create a thread that runs in the virtual address space of another process and optionally specify extended attributes.
            </summary>
            <param name="hProcess">
            A handle to the process in which the thread is to be created. The handle must have the PROCESS_CREATE_THREAD,
            PROCESS_QUERY_INFORMATION, PROCESS_VM_OPERATION, PROCESS_VM_WRITE, and PROCESS_VM_READ access rights, and may fail without
            these rights on certain platforms. For more information, see Process Security and Access Rights.
            </param>
            <param name="lpThreadAttributes">
            A pointer to a SECURITY_ATTRIBUTES structure that specifies a security descriptor for the new thread and determines whether
            child processes can inherit the returned handle. If lpThreadAttributes is NULL, the thread gets a default security descriptor
            and the handle cannot be inherited. The access control lists (ACL) in the default security descriptor for a thread come from
            the primary token of the creator.
            </param>
            <param name="dwStackSize">
            The initial size of the stack, in bytes. The system rounds this value to the nearest page. If this parameter is 0 (zero), the
            new thread uses the default size for the executable. For more information, see Thread Stack Size.
            </param>
            <param name="lpStartAddress">
            A pointer to the application-defined function of type LPTHREAD_START_ROUTINE to be executed by the thread and represents the
            starting address of the thread in the remote process. The function must exist in the remote process. For more information,
            see ThreadProc.
            </param>
            <param name="lpParameter">
            A pointer to a variable to be passed to the thread function.
            </param>
            <param name="dwCreationFlags">
            The flags that control the creation of the thread.
            </param>
            <param name="lpThreadId">
            A pointer to a variable that receives the thread identifier. If this parameter is NULL, the thread identifier is not returned.
            </param>
            <returns>
            If the function succeeds, the return value is a handle to the new thread. If the function fails, the return value is
            NULL.To get extended error information, call GetLastError. Note that CreateRemoteThread may succeed even if lpStartAddress
            points to data, code, or is not accessible. If the start address is invalid when the thread runs, an exception occurs, and
            the thread terminates. Thread termination due to a invalid start address is handled as an error exit for the thread's process.
            This behavior is similar to the asynchronous nature of CreateProcess, where the process is created even if it refers to
            invalid or missing dynamic-link libraries (DLL).
            </returns>
        </member>
        <member name="M:Dalamud.Injector.NativeFunctions.GetExitCodeThread(System.IntPtr,System.UInt32@)">
            <summary>
            Retrieves the termination status of the specified thread.
            </summary>
            <param name="hThread">
            A handle to the thread. The handle must have the THREAD_QUERY_INFORMATION or THREAD_QUERY_LIMITED_INFORMATION
            access right.For more information, see Thread Security and Access Rights.
            </param>
            <param name="lpExitCode">
            A pointer to a variable to receive the thread termination status.
            </param>
            <returns>
            If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
            extended error information, call GetLastError.
            </returns>
        </member>
        <member name="M:Dalamud.Injector.NativeFunctions.OpenProcess(Dalamud.Injector.NativeFunctions.ProcessAccessFlags,System.Boolean,System.Int32)">
            <summary>
            Opens an existing local process object.
            </summary>
            <param name="dwDesiredAccess">
            The access to the process object. This access right is checked against the security descriptor for the process. This parameter can be one or
            more of the process access rights. If the caller has enabled the SeDebugPrivilege privilege, the requested access is granted regardless of the
            contents of the security descriptor.
            </param>
            <param name="bInheritHandle">
            If this value is TRUE, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.
            </param>
            <param name="dwProcessId">
            The identifier of the local process to be opened. If the specified process is the System Idle Process(0x00000000), the function fails and the
            last error code is ERROR_INVALID_PARAMETER.If the specified process is the System process or one of the Client Server Run-Time Subsystem(CSRSS)
            processes, this function fails and the last error code is ERROR_ACCESS_DENIED because their access restrictions prevent user-level code from
            opening them. If you are using GetCurrentProcessId as an argument to this function, consider using GetCurrentProcess instead of OpenProcess, for
            improved performance.
            </param>
            <returns>
            If the function succeeds, the return value is an open handle to the specified process.
            If the function fails, the return value is NULL.To get extended error information, call GetLastError.
            </returns>
        </member>
        <member name="M:Dalamud.Injector.NativeFunctions.VirtualAllocEx(System.IntPtr,System.IntPtr,System.Int32,Dalamud.Injector.NativeFunctions.AllocationType,Dalamud.Injector.NativeFunctions.MemoryProtection)">
            <summary>
            See https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex.
            Reserves, commits, or changes the state of a region of memory within the virtual address space of a specified process.
            The function initializes the memory it allocates to zero. To specify the NUMA node for the physical memory, see
            VirtualAllocExNuma.
            </summary>
            <param name="hProcess">
            The handle to a process. The function allocates memory within the virtual address space of this process. The handle
            must have the PROCESS_VM_OPERATION access right. For more information, see Process Security and Access Rights.
            </param>
            <param name="lpAddress">
            The pointer that specifies a desired starting address for the region of pages that you want to allocate. If you
            are reserving memory, the function rounds this address down to the nearest multiple of the allocation granularity.
            If you are committing memory that is already reserved, the function rounds this address down to the nearest page
            boundary. To determine the size of a page and the allocation granularity on the host computer, use the GetSystemInfo
            function. If lpAddress is NULL, the function determines where to allocate the region. If this address is within
            an enclave that you have not initialized by calling InitializeEnclave, VirtualAllocEx allocates a page of zeros
            for the enclave at that address. The page must be previously uncommitted, and will not be measured with the EEXTEND
            instruction of the Intel Software Guard Extensions programming model. If the address in within an enclave that you
            initialized, then the allocation operation fails with the ERROR_INVALID_ADDRESS error.
            </param>
            <param name="dwSize">
            The size of the region of memory to allocate, in bytes. If lpAddress is NULL, the function rounds dwSize up to the
            next page boundary. If lpAddress is not NULL, the function allocates all pages that contain one or more bytes in
            the range from lpAddress to lpAddress+dwSize. This means, for example, that a 2-byte range that straddles a page
            boundary causes the function to allocate both pages.
            </param>
            <param name="flAllocationType">
            The type of memory allocation. This parameter must contain one of the MEM_* enum values.
            </param>
            <param name="flProtect">
            The memory protection for the region of pages to be allocated. If the pages are being committed, you can specify
            any one of the memory protection constants.
            </param>
            <returns>
            If the function succeeds, the return value is the base address of the allocated region of pages. If the function
            fails, the return value is NULL.To get extended error information, call GetLastError.
            </returns>
        </member>
        <member name="M:Dalamud.Injector.NativeFunctions.VirtualFreeEx(System.IntPtr,System.IntPtr,System.Int32,Dalamud.Injector.NativeFunctions.AllocationType)">
            <summary>
            See https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualfreeex.
            Releases, decommits, or releases and decommits a region of memory within the virtual address space of a specified
            process.
            </summary>
            <param name="hProcess">
            A handle to a process. The function frees memory within the virtual address space of the process. The handle must
            have the PROCESS_VM_OPERATION access right.For more information, see Process Security and Access Rights.
            </param>
            <param name="lpAddress">
            A pointer to the starting address of the region of memory to be freed. If the dwFreeType parameter is MEM_RELEASE,
            lpAddress must be the base address returned by the VirtualAllocEx function when the region is reserved.
            </param>
            <param name="dwSize">
            The size of the region of memory to free, in bytes. If the dwFreeType parameter is MEM_RELEASE, dwSize must be 0
            (zero). The function frees the entire region that is reserved in the initial allocation call to VirtualAllocEx.
            If dwFreeType is MEM_DECOMMIT, the function decommits all memory pages that contain one or more bytes in the range
            from the lpAddress parameter to (lpAddress+dwSize). This means, for example, that a 2-byte region of memory that
            straddles a page boundary causes both pages to be decommitted. If lpAddress is the base address returned by
            VirtualAllocEx and dwSize is 0 (zero), the function decommits the entire region that is allocated by VirtualAllocEx.
            After that, the entire region is in the reserved state.
            </param>
            <param name="dwFreeType">
            The type of free operation. This parameter must be one of the MEM_* enum values.
            </param>
            <returns>
            If the function succeeds, the return value is a nonzero value. If the function fails, the return value is 0 (zero).
            To get extended error information, call GetLastError.
            </returns>
        </member>
        <member name="M:Dalamud.Injector.NativeFunctions.WaitForSingleObject(System.IntPtr,System.UInt32)">
            <summary>
            Waits until the specified object is in the signaled state or the time-out interval elapses. To enter an alertable wait
            state, use the WaitForSingleObjectEx function.To wait for multiple objects, use WaitForMultipleObjects.
            </summary>
            <param name="hHandle">
            A handle to the object. For a list of the object types whose handles can be specified, see the following Remarks section.
            If this handle is closed while the wait is still pending, the function's behavior is undefined. The handle must have the
            SYNCHRONIZE access right. For more information, see Standard Access Rights.
            </param>
            <param name="dwMilliseconds">
            The time-out interval, in milliseconds. If a nonzero value is specified, the function waits until the object is signaled
            or the interval elapses. If dwMilliseconds is zero, the function does not enter a wait state if the object is not signaled;
            it always returns immediately. If dwMilliseconds is INFINITE, the function will return only when the object is signaled.
            </param>
            <returns>
            If the function succeeds, the return value indicates the event that caused the function to return.
            It can be one of the WaitResult values.
            </returns>
        </member>
        <member name="M:Dalamud.Injector.NativeFunctions.WriteProcessMemory(System.IntPtr,System.IntPtr,System.Byte[],System.Int32,System.IntPtr@)">
            <summary>
            Writes data to an area of memory in a specified process. The entire area to be written to must be accessible or
            the operation fails.
            </summary>
            <param name="hProcess">
            A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access
            to the process.
            </param>
            <param name="lpBaseAddress">
            A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the
            system verifies that all data in the base address and memory of the specified size is accessible for write access,
            and if it is not accessible, the function fails.
            </param>
            <param name="lpBuffer">
            A pointer to the buffer that contains data to be written in the address space of the specified process.
            </param>
            <param name="dwSize">
            The number of bytes to be written to the specified process.
            </param>
            <param name="lpNumberOfBytesWritten">
            A pointer to a variable that receives the number of bytes transferred into the specified process. This parameter
            is optional. If lpNumberOfBytesWritten is NULL, the parameter is ignored.
            </param>
            <returns>
            If the function succeeds, the return value is nonzero. If the function fails, the return value is 0 (zero). To get
            extended error information, call GetLastError.The function fails if the requested write operation crosses into an
            area of the process that is inaccessible.
            </returns>
        </member>
        <member name="M:Dalamud.Injector.NativeFunctions.DuplicateHandle(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr@,System.UInt32,System.Boolean,Dalamud.Injector.NativeFunctions.DuplicateOptions)">
             <summary>
             Duplicates an object handle.
             </summary>
             <param name="hSourceProcessHandle">
             A handle to the process with the handle to be duplicated.
            
             The handle must have the PROCESS_DUP_HANDLE access right.
             </param>
             <param name="hSourceHandle">
             The handle to be duplicated. This is an open object handle that is valid in the context of the source process.
             For a list of objects whose handles can be duplicated, see the following Remarks section.
             </param>
             <param name="hTargetProcessHandle">
             A handle to the process that is to receive the duplicated handle.
            
             The handle must have the PROCESS_DUP_HANDLE access right.
             </param>
             <param name="lpTargetHandle">
             A pointer to a variable that receives the duplicate handle. This handle value is valid in the context of the target process.
            
             If hSourceHandle is a pseudo handle returned by GetCurrentProcess or GetCurrentThread, DuplicateHandle converts it to a real handle to a process or thread, respectively.
            
             If lpTargetHandle is NULL, the function duplicates the handle, but does not return the duplicate handle value to the caller. This behavior exists only for backward compatibility with previous versions of this function. You should not use this feature, as you will lose system resources until the target process terminates.
            
             This parameter is ignored if hTargetProcessHandle is NULL.
             </param>
             <param name="dwDesiredAccess">
             The access requested for the new handle. For the flags that can be specified for each object type, see the following Remarks section.
            
             This parameter is ignored if the dwOptions parameter specifies the DUPLICATE_SAME_ACCESS flag. Otherwise, the flags that can be specified depend on the type of object whose handle is to be duplicated.
            
             This parameter is ignored if hTargetProcessHandle is NULL.
             </param>
             <param name="bInheritHandle">
             A variable that indicates whether the handle is inheritable. If TRUE, the duplicate handle can be inherited by new processes created by the target process. If FALSE, the new handle cannot be inherited.
            
             This parameter is ignored if hTargetProcessHandle is NULL.
             </param>
             <param name="dwOptions">
             Optional actions.
             </param>
             <returns>
             If the function succeeds, the return value is nonzero.
            
             If the function fails, the return value is zero. To get extended error information, call GetLastError.
             </returns>
             <remarks>
             See https://docs.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-duplicatehandle.
             </remarks>
        </member>
    </members>
</doc>
